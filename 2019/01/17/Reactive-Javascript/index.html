<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="Hans Blog"><meta name="keywords" content="Hans Blog"><title>Reactive Javascript - Hans Huang</title><link rel="stylesheet" href="/style/main.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="/archives"><span>Achive</span></a></li><li><a href="https://github.com/HansHuang"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="/images/post_background.jpg"><div class="post-title"><h1 class="title">Reactive Javascript</h1><ul class="meta"><li><i class="icon icon-author"></i>Hans Huang</li><li><i class="icon icon-clock"></i>65 Minutes</li><li><i class="icon icon-calendar"></i>January 17, 2019</li></ul></div></div><div class="article-content" style="max-width:1200px"><p>From Wikipedia:</p>
<blockquote>
<p>Reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change.</p>
</blockquote>
<h2 id="Pull-amp-Push-System"><a href="#Pull-amp-Push-System" class="headerlink" title="Pull &amp; Push System"></a>Pull &amp; Push System</h2><p>As the action direction, the <em>Pull</em> and <em>Push</em> describe the communication initiative between data <strong>Producer</strong> and <strong>Consumer</strong>.</p>
<p>In the <strong>pull</strong> system the data <strong>consumer</strong> determines when to get data, producer just need to get data prepared (in cache or call-by-need).<br>In the <strong>push</strong> system the data <strong>producer</strong> determines when to send data, consumer just need to get ready to process data.</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>In Javascript ecosystem, the most commonly used library is <a href="https://github.com/reactivex/rxjs" target="_blank" rel="noopener">RxJS</a> (yes, the Reactive Extension family).<br>The Reactive Extension introduces a new data model named <strong>“Observable”</strong> to stands for push system.<br>Below is a comparison between Observable and other data models we familiar in javascript.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Evaluation</th>
<th>Execution</th>
<th>Return Value Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>Function</td>
<td>Lazy</td>
<td>Synchronous</td>
<td>1</td>
</tr>
<tr>
<td>Generator</td>
<td>Lazy</td>
<td>Synchronous</td>
<td>0 ~ Infinity</td>
</tr>
<tr>
<td>Promise</td>
<td>Eager</td>
<td>Asynchronous</td>
<td>1</td>
</tr>
<tr>
<td>Observable</td>
<td>Lazy</td>
<td><strong>Synchronous</strong></td>
<td>0 ~ Infinity</td>
</tr>
</tbody>
</table>
<p>Here highlight the sync execution for Observable, because someone (e.g. <a href="https://angular.io/guide/rx-library" target="_blank" rel="noopener">Angular</a>) think the  Reactive Programming is asynchronous , as well as RxJS, but it’s not true. Similar like a function, it can start a async execution, but the function body itself is executed synchronized.</p>
<p>Below sample code can help demonstrate it:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observable &#125; = <span class="built_in">require</span>(<span class="string">'rxjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Before send value'</span>)</span><br><span class="line">    observer.next(<span class="number">1</span>)</span><br><span class="line">    observer.next(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'After send value'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Before subscribe'</span>)</span><br><span class="line">observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After subscribe'</span>)</span><br></pre></td></tr></table></figure>
<p>The output is printed synchronized:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before subscribe</span><br><span class="line">Before send value</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">After send value</span><br><span class="line">After subscribe</span><br></pre></td></tr></table></figure></p>
<p>From above demo code you may found Observable looks like an event emitter. But there is significant difference between them:<br>For event emitter, no matter how many the listeners(0 to infinity), it will always be executed, and only once.<br>For Observable, the execution depends on count of subscriptions: no subscription no execution, 100 subscription then 100 execution.</p>
<p>There will be 3 <em>“generating value”</em> printed for below demo code:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observable &#125; = <span class="built_in">require</span>(<span class="string">'rxjs'</span>)</span><br><span class="line"><span class="keyword">const</span> observable = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'generating value'</span>)</span><br><span class="line">    observer.next(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observable.subscribe()</span><br><span class="line">observable.subscribe()</span><br><span class="line">observable.subscribe()</span><br></pre></td></tr></table></figure></p>
<h3 id="Life-cycle"><a href="#Life-cycle" class="headerlink" title="Life cycle"></a>Life cycle</h3><p>From pervious demo code, the data is directly send by observer, but the <em>next()</em> is not its only functionality.<br>See below definition of <strong>Observer</strong>, it can explicitly terminate data producing by calling <em>complete()</em> or calling <em>error()</em> method if there is error exception.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface Observer&lt;T&gt; &#123;</span><br><span class="line">    closed?: boolean;</span><br><span class="line">    next: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">    error: <span class="function">(<span class="params">err: any</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Corresponding for the subscriber can register 3 callbacks in <em>subscribe()</em> method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> declare <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">Subscribable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//hide other class members</span></span><br><span class="line"></span><br><span class="line">    subscribe(next?: <span class="function">(<span class="params">value: T</span>) =&gt;</span> <span class="keyword">void</span>, error?: <span class="function">(<span class="params">error: any</span>) =&gt;</span> <span class="keyword">void</span>, complete?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>): Subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You may found there is a <em>Subscription</em> object returned by the <em>subscribe()</em> method.<br>This means not only the <em>Observer</em>(data producer), but also the <em>subscriber</em>(data consumer) can terminate data flow.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> declare <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> <span class="title">implements</span> <span class="title">SubscriptionLike</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hide other class members</span></span><br><span class="line"></span><br><span class="line">    closed: boolean;</span><br><span class="line">    </span><br><span class="line">    unsubscribe(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reminder: No matter the termination comes from Observer or Subscriber, the Observable <strong>may not</strong> completely disposed.</p>
<p>As below demo code, the “sending value” will be kept printing after subscription is closed:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'sending value'</span>)</span><br><span class="line">        observer.next(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return () =&gt; clearInterval(id)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscription = observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Subscription is closed: <span class="subst">$&#123;subscription.closed&#125;</span>`</span>) <span class="comment">// true</span></span><br><span class="line">&#125;, <span class="number">3</span> * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>As you assumed the solution is the commented line: return a resource dispose function when creating observable.</p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>From above demo code you may found the <em>Observable</em> is unicast, every subscription has its own separate execution.<br>What if we want multiple subscriptions share a singleton execution(multicast) ? Then we can try <strong>“Subject”</strong>.<br>From this perspective, a Subject is more like a EventEmitter.</p>
<p>Subject class inherent Observable, so all observable functions &amp; properties could be found inside.<br>But a new subscription won’t start a new execution, it will be added to internal subscription list.<br>It also can deliver value to subscriptions directly, since it wraps all members of Observer(closed, next(), error(), complete()).</p>
<p>So from usage perspective, a Subject could be Observable or a Observer, it depends on you need.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Subject, <span class="keyword">from</span> &#125; = <span class="built_in">require</span>(<span class="string">'rxjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line">subject.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`A: <span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line">subject.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`B: <span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below line: subject plays as a Observable</span></span><br><span class="line">subject.next(<span class="string">'Hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below 2 lines: subject plays as a Observer</span></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">observable.subscribe(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below line: subject plays as a Observable again, but it won't be effective</span></span><br><span class="line">subject.next(<span class="string">'World'</span>)</span><br></pre></td></tr></table></figure>
<p>Below are the output, the “World” won’t be printed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A: Hello</span><br><span class="line">B: Hello</span><br><span class="line">A: 1</span><br><span class="line">B: 1</span><br><span class="line">A: 2</span><br><span class="line">B: 2</span><br><span class="line">A: 3</span><br><span class="line">B: 3</span><br></pre></td></tr></table></figure>
<p>With the multicast feature of a subject, an existing observable could be multicast as well, see te <a href="https://www.learnrxjs.io/operators/multicasting/multicast.html" target="_blank" rel="noopener">multicast</a> operator.</p>
<p>Below are several handy Subject derivations provide by RX:</p>
<ul>
<li><p><a href="https://www.learnrxjs.io/subjects/behaviorsubject.html" target="_blank" rel="noopener">BehaviorSubject</a>: the latest (or initial) value will be remembered, and will deliver to every new subscription.</p>
</li>
<li><p><a href="https://www.learnrxjs.io/subjects/replaysubject.html" target="_blank" rel="noopener">ReplaySubject</a>: similar as BehaviorSubject, it can remember multiple values, and deliver to new subscriptions.</p>
</li>
<li><p><a href="https://www.learnrxjs.io/subjects/asyncsubject.html" target="_blank" rel="noopener">AsyncSubject</a>: don’t misleading by the name, there is nothing relation with async execution, this subject will only deliver the last value (only once) before completion.</p>
</li>
</ul>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>If you ever check some source codes which import Rx, you may be confuse with its variety operations (functions). Look twice to the operation, they are all pure function and provide functional programming style, regards data flow as list to transform, filter, consolidate…<br>Below are major categories for operations (we can refer with functional programming methods): </p>
<ul>
<li><p>Creation</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/create.html" target="_blank" rel="noopener">Create</a>, <a href="http://reactivex.io/documentation/operators/defer.html" target="_blank" rel="noopener">Defer</a>: create observable eagerly or lazily.</li>
<li><a href="http://reactivex.io/documentation/operators/from.html" target="_blank" rel="noopener">From</a>, <a href="http://reactivex.io/documentation/operators/range.html" target="_blank" rel="noopener">Range</a>, <a href="http://reactivex.io/documentation/operators/repeat.html" target="_blank" rel="noopener">Repeat</a>: create observable and emit provided values by iteration.</li>
<li><a href="http://reactivex.io/documentation/operators/just.html" target="_blank" rel="noopener">Just</a>, <a href="http://reactivex.io/documentation/operators/start.html" target="_blank" rel="noopener">Start</a>: create observable and emit one value by provide it directly or execute a function</li>
<li><a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="noopener">Interval</a>, <a href="http://reactivex.io/documentation/operators/timer.html" target="_blank" rel="noopener">Timer</a>: create observable and emit values in specific time interval or timeout.</li>
<li><a href="http://reactivex.io/documentation/operators/empty-never-throw.html" target="_blank" rel="noopener">Empty/Never/Throw</a>: create observable without emit values, but directly terminate or never terminate or throw error.</li>
</ul>
</li>
<li><p>Transform</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="noopener">Map</a>(Select),<a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">FlatMap</a>(SelectMany): transform and then emit the values from one or multiple observables.</li>
<li><a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="noopener">Scan</a>, <a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="noopener">Reduce</a>: apply a function which accept 2 parameters(previous/initial value, current value) to calculate a new value, and then emit them individually or only emit final value.</li>
<li><a href="http://reactivex.io/documentation/operators/groupby.html" target="_blank" rel="noopener">GroupBy</a>, <a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="noopener">Window</a>, <a href="http://reactivex.io/documentation/operators/buffer.html" target="_blank" rel="noopener">Buffer</a>: subdivide and emit values by specific group key, or emit in a fix time period, or some other boundary selectors.</li>
</ul>
</li>
<li><p>Filter</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/first.html" target="_blank" rel="noopener">First</a>, <a href="http://reactivex.io/documentation/operators/last.html" target="_blank" rel="noopener">Last</a>, <a href="http://reactivex.io/documentation/operators/elementat.html" target="_blank" rel="noopener">ElementAt</a>: filter and emit one value by specific condition</li>
<li><a href="http://reactivex.io/documentation/operators/filter.html" target="_blank" rel="noopener">Filter</a>, <a href="http://reactivex.io/documentation/operators/distinct.html" target="_blank" rel="noopener">Distinct</a>, <a href="http://reactivex.io/documentation/operators/sample.html" target="_blank" rel="noopener">Sample</a>, <a href="http://reactivex.io/documentation/operators/distinct.html" target="_blank" rel="noopener">Debounce</a>: filter and emit values by specific condition, or the latest item in a particular time interval or timespan.</li>
<li><a href="http://reactivex.io/documentation/operators/skip.html" target="_blank" rel="noopener">Skip</a>, <a href="http://reactivex.io/documentation/operators/skiplast.html" target="_blank" rel="noopener">SkipLast</a>, <a href="http://reactivex.io/documentation/operators/take.html" target="_blank" rel="noopener">Take</a>, <a href="http://reactivex.io/documentation/operators/takelast.html" target="_blank" rel="noopener">TakeLast</a>, <a href="http://reactivex.io/documentation/operators/ignoreelements.html" target="_blank" rel="noopener">IgnoreElements</a>: ignore some items by its index, or ignore all of them and emit termination directly.</li>
<li><a href="http://reactivex.io/documentation/operators/skipwhile.html" target="_blank" rel="noopener">SkipWhile</a>, <a href="http://reactivex.io/documentation/operators/takewhile.html" target="_blank" rel="noopener">TakeWhile</a>: ignore or only take some item while match specific condition.</li>
<li><a href="http://reactivex.io/documentation/operators/skipuntil.html" target="_blank" rel="noopener">SkipUntil</a>, <a href="http://reactivex.io/documentation/operators/takeuntil.html" target="_blank" rel="noopener">TakeUntil</a>: ignore or take items until second observable emit values.</li>
<li><a href="http://reactivex.io/documentation/operators/amb.html" target="_blank" rel="noopener">Amb</a>(like Match): from multiple observables, emit one’s values which emit value first.</li>
</ul>
</li>
<li><p>Combination</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/combinelatest.html" target="_blank" rel="noopener">CombineLatest/WithLatestFrom</a>, <a href="http://reactivex.io/documentation/operators/zip.html" target="_blank" rel="noopener">Zip</a>, <a href="http://reactivex.io/documentation/operators/join.html" target="_blank" rel="noopener">Join</a>: combine multiple observables, use a callback function to accept and calculate with their latest values or values in sequence or in specific time window.</li>
<li><a href="http://reactivex.io/documentation/operators/concat.html" target="_blank" rel="noopener">Concat</a>: emit the values from multiple observables without interleaving them.</li>
<li><a href="http://reactivex.io/documentation/operators/merge.html" target="_blank" rel="noopener">Merge</a>, <a href="http://reactivex.io/documentation/operators/startwith.html" target="_blank" rel="noopener">StartWith</a>, <a href="https://rxjs.dev/api/operators/switchAll" target="_blank" rel="noopener">switchAll</a>: combine multiple observables, and them emit their values in sequence.</li>
</ul>
</li>
<li><p>Predication</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/all.html" target="_blank" rel="noopener">All</a>, <a href="http://reactivex.io/documentation/operators/contains.html" target="_blank" rel="noopener">Contains</a>: determine whether all or any items meet specific criteria.</li>
<li><a href="http://reactivex.io/documentation/operators/sequenceequal.html" target="_blank" rel="noopener">SequenceEqual</a>: determine whether two Observables emit the same sequence of items</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/average.html" target="_blank" rel="noopener">Average</a>, <a href="http://reactivex.io/documentation/operators/count.html" target="_blank" rel="noopener">Count</a>, <a href="http://reactivex.io/documentation/operators/max.html" target="_blank" rel="noopener">Max</a>, <a href="http://reactivex.io/documentation/operators/min.html" target="_blank" rel="noopener">Min</a>, <a href="http://reactivex.io/documentation/operators/sum.html" target="_blank" rel="noopener">Sum</a>: Math calculate with all values from observable and only emit the result value.</li>
</ul>
</li>
<li><p>Error Handler</p>
<ul>
<li><a href="https://rxjs.dev/api/operators/catchError" target="_blank" rel="noopener">catchError</a>: catch error from observable, and then continue with a different observable or throw a new error.</li>
<li><a href="http://reactivex.io/documentation/operators/retry.html" target="_blank" rel="noopener">Retry</a>: mirror a source observable, continue emitting value and skip the error.</li>
</ul>
</li>
<li><p>Utility</p>
</li>
</ul>
<p>More documentation:</p>
<ul>
<li><a href="https://rxjs.dev/api" target="_blank" rel="noopener">https://rxjs.dev/api</a></li>
<li><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">http://reactivex.io/documentation/operators.html</a></li>
</ul>
<h2 id="Functional-Reactive-Programming"><a href="#Functional-Reactive-Programming" class="headerlink" title="Functional Reactive Programming"></a>Functional Reactive Programming</h2><p>// TBD</p>
</div><div class="article-meta" style="max-width:1200px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactive/">Reactive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJS/">RxJS</a><span class="tag-list-count">1</span></li></ul></div></div><div id="comments" style="max-width:1200px;margin: 10px auto"></div><script src="/js/gitment.browser.js"></script><script>var gitment = new Gitment({"owner":"HansHuang","repo":"hanshuang.github.io","oauth":{"client_id":"d8c223c059942aca38a7","client_secret":"c71488c508dfb6cfeb2b4a0c926657f83a42f8de"}});gitment.render('comments');</script><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/11/28/FP-JS/Functional-Meta-Programming/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/HansHuang" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.linkedin.com/in/hans-huang-0a6bb0b5/" title="Linkedin" target="_blank"><i class="icon icon-linkin"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Hans Huang</p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>